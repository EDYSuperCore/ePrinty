# ePrinty 日志清理总结

## 修改概述

本次修改清理了"额外检测与过度日志"，保留最小可诊断闭环，不改变现有成功路径行为。

## 日志封装入口定位

### 已记录的日志封装入口：

1. **文件日志封装**：`src-tauri/src/platform/windows/log.rs`
   - `write_log()`: 写入到 `%LOCALAPPDATA%\ePrinty\logs\printer-detect.log`
   - `truncate()`: 字符串截断辅助函数（默认 2000 字符）
   - `sanitize_path()`: 路径脱敏（仅保留文件名或 %TEMP% 相对路径）

2. **PowerShell 执行日志**：`src-tauri/src/platform/windows/ps.rs`
   - `run_powershell()`: 统一执行 PowerShell 命令，记录关键执行信息

3. **打印测试页日志**：`src-tauri/src/platform/windows/test_page.rs`
   - `print_test_page_windows()`: 所有 eprintln! 调用集中在此函数

## 已完成的修改

### Step 1: 日志降噪

#### A. PowerShell 日志降噪

**删除的日志**：
- ❌ `[PowerShell] ARGS: powershell ... -Command <script>` - 已删除
- ❌ `PS_PRIMARY_SCRIPT (multiline)` - 已删除
- ❌ `PS_PRIMARY_SCRIPT (single_line)` - 已删除
- ❌ `PS_FALLBACK_SCRIPT` - 已删除（整个 fallback 分支已移除）

**保留的日志**（INFO 级别）：
- ✅ `[PowerShell] START: script_len, timeout_secs`
- ✅ `[PowerShell] PROCESS_COMPLETE: exit_code, elapsed_secs`
- ✅ `[PowerShell] SUCCESS/ERROR: stdout_len/stderr_len`
- ✅ stdout/stderr 的截断摘要（使用 `truncate()` 函数，默认 2000 字符）

#### B. TEMP_FILE 日志降噪

**删除的日志**：
- ❌ `first_16_bytes_hex` - 已删除

**保留的日志**：
- ✅ `TEMP_FILE_CREATE path` - 使用 `sanitize_path()` 脱敏（仅显示 `%TEMP%\filename`）
- ✅ `TEMP_FILE_CREATE result size` - 文件大小
- ✅ `TEMP_FILE_DELETE success/fail` - 删除结果

#### C. stdout/stderr 输出截断策略

**新增统一封装函数**：`src-tauri/src/platform/windows/log.rs::truncate()`

```rust
pub fn truncate(s: &str, max_len: usize) -> String
```

- 默认 `max_len=2000`
- 超过时保留前 `max_len` 字符，追加 `"...<truncated>"`
- 所有 stdout/stderr 输出都使用此函数截断

### Step 2: 清理"额外检测"与复杂分支

#### A. 删除 CIM fallback 分支

**修改前**：主路径失败后，会尝试 CIM `PrintTestPage` 方法作为备选

**修改后**：删除整个 fallback 分支，主链路固定为：
1. Get-Printer exists check（仅一次）
2. 生成临时文件
3. `content | Out-Printer -Name '<printer>'`
4. 清理临时文件

**删除的代码**：
- ❌ `FALLBACK_TO_CIM` 日志
- ❌ `PS_FALLBACK_SCRIPT` 日志
- ❌ `PS_FALLBACK_RESULT` 日志
- ❌ 整个 CIM fallback 执行逻辑（约 50 行代码）

#### B. 保留必要的存在性检查

**保留**：仅一次 `Get-Printer` 检查
- 检查脚本：`Get-Printer -Name '<name>' -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Name`
- `exists=false` 时直接返回明确错误，不进入后续分支

### Step 3: 失败时补齐"证据日志"

#### A. 新增 `print_printer_evidence()` 函数

**功能**：仅在失败时调用，输出关键证据信息

**输出内容**：
1. **打印机详细信息**（DriverName、PortName）
   - 脚本：`Get-Printer -Name '<name>' | Select-Object Name, DriverName, PortName | ConvertTo-Json -Compress`
   - 截断：500 字符
   - 日志格式：`[PrintTestPage] EVIDENCE step={step} printer_info="{...}"`

2. **权限信息**（PermissionSDDL）
   - 脚本：`Get-Printer -Name '<name>' | Select-Object -ExpandProperty PermissionSDDL`
   - 截断：4000 字符
   - 日志格式：`[PrintTestPage] EVIDENCE step={step} permission_sddl="{...}"`

**调用时机**：
- `CHECK_EXISTS` 失败时
- `PS_EXEC` 失败时
- `PS_RESULT` 失败时

### Step 4: 统一日志级别与格式

#### 成功路径输出（INFO）

```
[PrintTestPage] START printer_name="..."
[PrintTestPage] CHECK_EXISTS result exists=true exit_code=Some(0)
[PrintTestPage] TEMP_FILE_CREATE path="%TEMP%\printer_test_12345.txt"
[PrintTestPage] TEMP_FILE_CREATE result size=1237 bytes
[PowerShell] START script_len=... timeout_secs=120
[PowerShell] PROCESS_COMPLETE exit_code=Some(0) elapsed_secs=0.52
[PowerShell] SUCCESS exit_code=Some(0) stdout_len=7 stderr_len=0
[PrintTestPage] EXEC result exit_code=Some(0) stdout_len=7 stderr_len=0
[PrintTestPage] TEMP_FILE_DELETE success path="%TEMP%\printer_test_12345.txt"
[PrintTestPage] SUCCESS printer_name="..."
```

#### 失败路径输出（ERROR）

```
[PrintTestPage] START printer_name="..."
[PrintTestPage] CHECK_EXISTS result exists=false exit_code=Some(0)
[PrintTestPage] EVIDENCE step=CHECK_EXISTS printer_info="{...}"
[PrintTestPage] EVIDENCE step=CHECK_EXISTS permission_sddl="{...}"
[PrintTestPage] ERROR step=CHECK_EXISTS message=打印机不存在或未连接: ...
```

或

```
[PrintTestPage] START printer_name="..."
[PrintTestPage] CHECK_EXISTS result exists=true exit_code=Some(0)
[PrintTestPage] TEMP_FILE_CREATE path="%TEMP%\printer_test_12345.txt"
[PrintTestPage] TEMP_FILE_CREATE result size=1237 bytes
[PowerShell] START script_len=... timeout_secs=120
[PowerShell] PROCESS_COMPLETE exit_code=Some(1) elapsed_secs=0.52
[PowerShell] SUCCESS exit_code=Some(1) stdout_len=0 stderr_len=50
[PrintTestPage] EXEC result exit_code=Some(1) stdout_len=0 stderr_len=50
[PrintTestPage] EVIDENCE step=PS_RESULT printer_info="{...}"
[PrintTestPage] EVIDENCE step=PS_RESULT permission_sddl="{...}"
[PrintTestPage] FAILURE printer_name="..." exit_code=Some(1) stderr="打印失败...<truncated>"
[PrintTestPage] ERROR step=PS_RESULT message=打印测试页失败: ...
```

### Step 5: 远程配置日志

**保持现状**（已符合要求）：
- 超时日志：`[WARN] 远程配置加载超时（已使用本地配置）` - 只输出一次
- 失败日志：`[WARN] 远程配置加载失败: ...（已使用本地配置）` - 只输出一次
- 更新日志：`[INFO] 检测到远程配置更新` - 仅在检测到更新时输出

## 修改文件清单

1. **src-tauri/src/platform/windows/log.rs**
   - 新增 `truncate()` 函数
   - 新增 `sanitize_path()` 函数
   - 添加日志封装入口注释

2. **src-tauri/src/platform/windows/ps.rs**
   - 删除 `[PowerShell] ARGS` 日志
   - 删除 `[PowerShell] SPAWN_SUCCESS` 日志
   - 统一错误日志格式：`[PowerShell] ERROR step={step} message={msg}`
   - 添加日志封装入口注释

3. **src-tauri/src/platform/windows/test_page.rs**
   - 删除 `PS_PRIMARY_SCRIPT` 日志（multiline + single_line）
   - 删除 `first_16_bytes_hex` 日志
   - 删除 `GEN_CONTENT start` 日志
   - 删除 `CHECK_EXISTS script` 日志
   - 删除整个 CIM fallback 分支（约 50 行）
   - 使用 `sanitize_path()` 脱敏临时文件路径
   - 使用 `truncate()` 截断 stdout/stderr
   - 新增 `print_printer_evidence()` 函数
   - 失败时自动输出证据信息
   - 统一日志格式和级别

## 验收标准

### ✅ 成功场景

- 本地已有打印机：执行 `print_test_page`，确认仍打印成功
- 日志不再输出脚本全文、hex、args
- 日志输出简洁，仅包含关键步骤

### ✅ 失败场景

- 打印机不存在：`print_test_page` 预期快速失败
- 日志包含 `exists=false` 的清晰原因
- 日志包含证据信息（printer_info、permission_sddl）

### ✅ 日志降噪

- 不再输出 PowerShell 脚本全文
- 不再输出文件 hex 内容
- 不再输出 PowerShell ARGS
- 路径已脱敏（仅显示 `%TEMP%\filename`）
- stdout/stderr 已截断（默认 2000 字符）

### ✅ 功能完整性

- 安装功能不受影响
- 打印测试页功能仍可用（主路径）
- 失败时输出必要证据

## 代码统计

- **删除的日志行数**：约 15 行
- **删除的代码行数**：约 50 行（CIM fallback 分支）
- **新增的函数**：2 个（`truncate()`、`sanitize_path()`、`print_printer_evidence()`）
- **修改的文件**：3 个

## 注意事项

1. 所有日志都输出到 `stderr`（通过 `eprintln!`），不影响正常返回值
2. 失败时的证据日志仅在失败时输出，成功路径不输出
3. 临时文件路径已脱敏，不会暴露完整用户名路径
4. stdout/stderr 内容已截断，避免日志过长
5. 不改变原有架构和实现方案，只做日志降噪和分支收敛

